## æ•°æ®ç»“æ„

æ˜¾ç„¶ï¼Œå¯¹äºä»»æ„ä¸€ä¸ª $t = nums2[i]$ è€Œè¨€ï¼Œæˆ‘ä»¬åº”å½“åœ¨å€™é€‰é›†åˆä¸­é€‰æ‹©**æ¯”å…¶å¤§çš„æœ€å°æ•°**ï¼Œè‹¥ä¸å­˜åœ¨è¿™æ ·çš„æ•°å­—ï¼Œåˆ™é€‰æ‹©å€™é€‰é›†åˆä¸­çš„**æœ€å°å€¼**ã€‚

åŒæ—¶ï¼Œç”±äº $nums1$ ç›¸åŒæ•°ä¼šå­˜åœ¨å¤šä¸ªï¼Œæˆ‘ä»¬è¿˜è¦å¯¹æŸä¸ªå…·ä½“æ•°å­—çš„å¯ç”¨æ¬¡æ•°è¿›è¡Œè®°å½•ã€‚

ä¹Ÿå°±æ˜¯æˆ‘ä»¬æ€»å…±æ¶‰åŠä¸¤ç±»æ“ä½œï¼š

1. å®æ—¶ç»´æŠ¤ä¸€ä¸ªå€™é€‰é›†åˆï¼Œè¯¥é›†åˆæ”¯æŒé«˜æ•ˆæŸ¥è¯¢æ¯”æŸä¸ªæ•°å¤§çš„æ•°å€¼æ“ä½œï¼›
2. å¯¹å€™é€‰é›†åˆä¸­æ¯ä¸ªæ•°å€¼çš„å¯ä½¿ç”¨æ¬¡æ•°è¿›è¡Œè®°å½•ï¼Œå½“ä½¿ç”¨åˆ°äº†å€™é€‰é›†åˆä¸­çš„æŸä¸ªæ•°åï¼Œè¦å¯¹å…¶è¿›è¡Œè®¡æ•°å‡ä¸€æ“ä½œï¼Œè‹¥è®¡æ•°ä¸º $0$ï¼Œåˆ™å°†è¯¥æ•°å€¼ä»å€™é€‰é›†åˆä¸­ç§»é™¤ã€‚

è®¡æ•°æ“ä½œå®¹æ˜“æƒ³åˆ°å“ˆå¸Œè¡¨ï¼Œè€Œå®æ—¶ç»´æŠ¤å€™é€‰é›†åˆå¹¶é«˜æ•ˆæŸ¥è¯¢å¯ä»¥ä½¿ç”¨åŸºäºçº¢é»‘æ ‘çš„ `TreeSet` æ•°æ®ç»“æ„ã€‚

ä»£ç ï¼š

* []

```Java
class Solution {
    public int[] advantageCount(int[] nums1, int[] nums2) {
        int n = nums1.length;
        TreeSet<Integer> tset = new TreeSet<>();
        Map<Integer, Integer> map = new HashMap<>();
        for (int x : nums1) {
            map.put(x, map.getOrDefault(x, 0) + 1);
            if (map.get(x) == 1) tset.add(x);
        }
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            Integer cur = tset.ceiling(nums2[i] + 1);
            if (cur == null) cur = tset.ceiling(-1);
            ans[i] = cur;
            map.put(cur, map.get(cur) - 1);
            if (map.get(cur) == 0) tset.remove(cur);
        }
        return ans;
    }
}
```

* []

```Python
from sortedcontainers import SortedList

class Solution:
    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:
        n = len(nums1)
        cnts, tset = defaultdict(int), SortedList()
        for i in range(n):
            cnts[nums1[i]] += 1
            if cnts[nums1[i]] == 1:
                tset.add(nums1[i])
        ans = [0] * n
        for i in range(n):
            t = nums2[i]
            if (idx := tset.bisect_left(t + 1)) == len(tset):
                idx = tset.bisect_left(-1)
            ans[i] = tset[idx]
            cnts[ans[i]] -= 1
            if cnts[ans[i]] == 0:
                tset.remove(ans[i])
        return ans
```

* æ—¶é—´å¤æ‚åº¦ï¼š$O(n\log{n})$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$

---

## æ’åº + åŒæŒ‡é’ˆ

åœ¨è§£æ³•ä¸€ä¸­ï¼Œæˆ‘ä»¬æ˜¯ä»æ¯ä¸ª $nums2[i]$ å‡ºå‘è€ƒè™‘ï¼Œä½¿ç”¨å“ªä¸ª $nums1[i]$ å»åŒ¹é…æœ€ä¸ºåˆé€‚ã€‚

å®é™…ä¸Šï¼Œæˆ‘ä»¬ä¹Ÿèƒ½ä» $nums1[i]$ å‡ºå‘ï¼Œè€ƒè™‘å°†å…¶ä¸å“ªä¸ª $nums2[i]$ è¿›è¡ŒåŒ¹é…ã€‚

ä¸ºäº†è®©æ¯ä¸ªå†³ç­–å›åˆå…·æœ‰ç‹¬ç«‹æ€§ï¼Œæˆ‘ä»¬éœ€è¦å¯¹ä¸¤æ•°ç»„è¿›è¡Œæ’åºï¼ŒåŒæ—¶ä¸ºäº†åœ¨æ„é€ ç­”æ¡ˆæ—¶ï¼Œèƒ½å¤Ÿå¯¹åº”å› `nums2` çš„åŸä¸‹æ ‡ï¼Œæ’åºå‰æˆ‘ä»¬éœ€è¦ä½¿ç”¨ã€Œå“ˆå¸Œè¡¨ã€è®°å½•æ¯ä¸ª $nums2[i]$ çš„ä¸‹æ ‡ä¸ºä½•å€¼ã€‚

ä½¿ç”¨å˜é‡ `l1` ä»£è¡¨å½“å‰å†³ç­–å°† $nums1[l1]$ åˆ†é…åˆ°å“ªä¸ª `nums2` çš„ä½ç½®ï¼Œä½¿ç”¨ `l2` å’Œ `r2` ä»£è¡¨å½“å‰ `nums2` ä¸­è¿˜æœ‰ $[l2, r2]$ ä½ç½®è¿˜å¾…å¡«å……ã€‚

å¯ä»¥è¯æ˜æˆ‘ä»¬åœ¨ä»å‰å¾€åç»™æ¯ä¸ª $nums1[l1]$ åˆ†é…å…·ä½“ä½ç½®æ—¶ï¼Œåˆ†é…çš„ä½ç½®åªä¼šåœ¨ `l2` å’Œ `r2` ä¸¤è€…ä¹‹é—´äº§ç”Ÿã€‚

ä»£ç ï¼š

* []

```Java
class Solution {
    public int[] advantageCount(int[] nums1, int[] nums2) {
        int n = nums1.length;
        Map<Integer, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < n; i++) {
            List<Integer> list = map.getOrDefault(nums2[i], new ArrayList<>());
            list.add(i);
            map.put(nums2[i], list);
        }
        Arrays.sort(nums1); Arrays.sort(nums2);
        int[] ans = new int[n];
        for (int l1 = 0, l2 = 0, r2 = n - 1; l1 < n; l1++) {
            int t = nums1[l1] > nums2[l2] ? l2 : r2;
            List<Integer> list = map.get(nums2[t]);
            int idx = list.remove(list.size() - 1);
            ans[idx] = nums1[l1];
            if (t == l2) l2++;
            else r2--;
        }
        return ans;
    }
}
```

* []

```Python
class Solution:
    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:
        n = len(nums1)
        mapping = defaultdict(list)
        for i in range(n):
            mapping[nums2[i]].append(i)
        nums1.sort()
        nums2.sort()
        ans = [0] * n
        l2, r2 = 0, n - 1
        for l1 in range(n):
            t = l2 if nums1[l1] > nums2[l2] else r2
            ans[mapping[nums2[t]].pop()] = nums1[l1]
            if t == l2:
                l2 += 1
            else:
                r2 -= 1
        return ans
```

* æ—¶é—´å¤æ‚åº¦ï¼š$O(n\log{n})$
* ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$

---

## åŠ é¤

**èŠ‚åç¬¬ä¸€å¤©ï¼ŒåŠ é¤ä¸€é“åŒç±»å‹é¢˜ç›® : [éš¾åº¦ 2.5/5ï¼Œæ•²é†’æ²‰ç¡å¿ƒçµçš„æ•°æ®ç»“æ„è¿ç”¨é¢˜](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247493710&idx=1&sn=2d6d4ee9f4b1ff1ea766ddf7ea57bf55) ğŸ‰ğŸ‰**

---

## æœ€å

**å¦‚æœæœ‰å¸®åŠ©åˆ°ä½ ï¼Œè¯·ç»™é¢˜è§£ç‚¹ä¸ªèµå’Œæ”¶è—ï¼Œè®©æ›´å¤šçš„äººçœ‹åˆ° ~ ("â–”â–¡â–”)/**

æ‰€æœ‰é¢˜è§£å·²ç»åŠ å…¥ [åˆ·é¢˜æŒ‡å—](https://github.com/SharingSource/LogicStack-LeetCode/wiki)ï¼Œæ¬¢è¿ star å“¦ ~
